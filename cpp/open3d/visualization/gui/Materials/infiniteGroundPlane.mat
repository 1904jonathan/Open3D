material {
    name : infiniteGroundPlane,
    shadingModel : unlit,
    vertexDomain : device,
    depthWrite : false,
    doubleSided: true,
    blending : transparent,
    
    parameters : [
        { type : float3,    name : baseColor },
        { type : sampler2d, name : albedo },
        { type : float,     name : aspectRatio }
    ],
    requires: [
        uv0
    ],
    variables : [
        near_world
    ]
}

vertex {
    void materialVertex(inout MaterialVertexInputs material) {
         float4 p = getPosition();
         //material.far_world = getWorldFromClipMatrix() * float4(p.x, p.y, 0.9, 1.0);
         //material.far_world = material.worldPosition;
         material.near_world = getWorldFromClipMatrix() * float4(p.x, p.y, 0.0, 1.0);
         //material.near_world.xyz * (1.0 / material.near_world.w);
         //material.far_world = mulMat4x4Float3(getWorldFromClipMatrix(), float3(p.x, p.y, 1.0));
         //material.near_world = mulMat4x4Float3(getWorldFromClipMatrix(), float3(p.x, p.y, 0.0));
         //material.far_world.xyz += getWorldOffset();
         //material.near_world.xyz += getWorldOffset();
         //material.far_world.xyz *= (1.0 / material.far_world.w);
         material.near_world.xyz *= (1.0 / material.near_world.w);
    }
}

fragment {
    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        float3 near = variable_near_world.xyz;
        float3 far = getWorldPosition().xyz;
        //float3 near = variable_near_world.xyz / variable_near_world.w;
        //float3 far = variable_far_world.xyz / variable_far_world.w;

        // Compute intersection with ground plane
        float t = (3.0 - near.y) / (far.y - near.y);

        // Compute world pos of the point on the plane in order to compute grid pattern
        float3 world_pos = near + t * (far - near);
        float2 plane_coord = world_pos.xz;
        float2 grid_derivative = fwidth(plane_coord);
        float2 grid = abs(fract(plane_coord - 0.5) - 0.5) / grid_derivative;
        float line = min(grid.x, grid.y);
        //float c = (int(round(wp.x)) + int(round(wp.z))) % 2;
        //float c = (int(round(getUV0().x*10.0)) + int(round(getUV0().y*10.0))) % 2;
        //c = c*0.6 + 0.2;
        //material.baseColor = float4(float(t > 0.0), float(t < 0.0), float(t==0.0), 1.0) * float(t > 0);
        //material.baseColor = float4(float(t > 0.0), float(t < 0.0), float(t==0.0), 1.0);
        //material.baseColor = float4(float(far.y == near.y), isinf(near.y), float(t>0), 1.0);
        material.baseColor = float4(0.2, 0.2, 0.2, 1.0 - min(line,1.0)) * float(t<0);
        //material.baseColor = float4(isnan(t), isinf(t), float(t==0.0), 1.0) * float(t > 0);
        //material.baseColor = float4(c, c, c, 1.0) * float(t>0);
    }
}
