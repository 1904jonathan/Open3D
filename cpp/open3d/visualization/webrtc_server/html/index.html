<html>
  <head>
    <title>Open3D WebVisualizer</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <link rel="icon" type="image/ico" href="open3d_logo.ico" />
    <script src="libs/adapter.min.js"></script>
    <script src="webrtcstreamer.js"></script>
    <script>
      /**
       * Global WebRTC configs
       */
      var webRtcOptions = "rtptransport=tcp&timeout=60";

      /**
       * WebRTC connections
       */
      var webRtcServerList = {};

      /**
       * Get the div where to insert a video
       */
      function getContentDiv() {
        var contentDiv = document.getElementById("content");
        return contentDiv;
      }

      function setDifference(setA, setB) {
        let _difference = new Set(setA);
        for (let elem of setB) {
          _difference.delete(elem);
        }
        return _difference;
      }

      /**
       * Init device list
       * @param {object} mediaList A map of media. E.g.
       * var mediaList = {
       *  0: {video: "window_0"},
       *  1: {video: "window_1"},
       * }
       * var url = mediaList["0"];            // {video: "window_0"}
       * var windowId = url.video;           // "window_0"
       * var videoId = "video_" + windowId; // "video_window_0"
       */
      function updateMediaList(mediaList) {
        // Create navigation menu.
        let menu = document.getElementById("menu");

        // The current video source that the server is serving.
        let validUrls = new Set();
        for (let key in mediaList) {
          validUrls.add(mediaList[key]);
        }

        // Collect stale and new URLs. This is needed to avoid "removing while
        // iterating".
        let existingUrls = new Set();
        let staleUrls = new Array();
        for (let i = 0; i < menu.children.length; i++) {
          let nav = menu.children[i];
          let url = nav.url;
          existingUrls.add(url);
          if (!validUrls.has(url)) {
            staleUrls.push(url);
          }
        }
        let newUrls = [...setDifference(validUrls, existingUrls)];

        // Remove stale URLs.
        staleUrls.forEach(function (url) {
          let windowId = url.video;
          let videoId = "video_" + windowId;
          let id = "nav_" + videoId;
          document.getElementById(id).remove();
        });

        // Append and connect to new URLs.
        newUrls.forEach(function (url) {
          let windowId = url.video;
          let videoId = "video_" + windowId;
          let navId = "nav_" + videoId;
          let nav = document.createElement("a");
          nav.url = url;
          nav.text = windowId;
          nav.id = navId;
          nav.onclick = function () {
            if (this.className === "active") {
              delConnection(this.windowId);
            } else {
              addConnection(this.windowId);
            }
          };
          menu.appendChild(nav);
        });

        // for (var key in mediaList) {
        //   var url = mediaList[key]; // e.g. url = {video: "window_0"}.
        //   var windowId = url.video; // e.g. "window_0".
        //   var videoId = "video_" + windowId; // e.g. "video_window_0"
        //   var nav = document.createElement("a");
        //   nav.url = url;
        //   nav.text = url.video;
        //   nav.id = "nav_" + videoId;
        //   nav.onclick = function () {
        //     if (this.className === "active") {
        //       delConnection(this.url.video);
        //     } else {
        //       addConnection(this.url.video);
        //     }
        //   };
        //   menu.appendChild(nav);
        // }

        newUrls.forEach((url) => {
          addConnection(url.video);
        });
      }

      /**
       * Delete a WebRTC client connection
       */
      function delConnection(windowId) {
        var videoId = "video_" + windowId;

        // Disconnect WebRTC connection
        var webrtcServer = webRtcServerList[videoId];
        if (webrtcServer) {
          webrtcServer.disconnect();
          webRtcServerList[videoId] = undefined;
        }
      }

      /**
       * Add a WebRTC client connection
       */
      function addConnection(windowId) {
        // url = {video: "window_1"}
        var videoId = "video_" + windowId;

        // Add a video element to display WebRTC stream
        if (document.getElementById(videoId) === null) {
          var contentDiv = getContentDiv();
          if (contentDiv) {
            var divElt = document.createElement("div");
            divElt.id = "div_" + videoId;

            var nameElt = document.createElement("h2");
            nameElt.id = "title_" + videoId;
            nameElt.innerHTML = "<div>" + windowId + "</div>";
            divElt.appendChild(nameElt);

            var videoElt = document.createElement("video");
            videoElt.id = videoId;
            videoElt.title = windowId;
            videoElt.muted = true;
            videoElt.controls = false;
            videoElt.playsinline = true;

            divElt.appendChild(videoElt);

            contentDiv.appendChild(divElt);
          }
        }

        var videoElt = document.getElementById(videoId);
        if (videoElt) {
          var onClose = function () {
            console.log("onClose() called for videoId:", videoId);

            // Remove the video element and its tile
            var divElt = document.getElementById("div_" + videoId);
            divElt.parentElement.removeChild(divElt);

            // Un-highlight the navigation
            var navElt = document.getElementById("nav_" + videoId);
            navElt.className = "";

            WebRtcStreamer.getMediaList()
              .then((response) => response.json())
              .then((response) => updateMediaList(response));
          };

          // Connect video element to WebRTC stream
          var webRtcClient = new WebRtcStreamer(videoId, "", onClose, null);
          console.log("[addConnection] videoId: " + videoId);

          webRtcClient.connect(windowId, /*audio*/ null, webRtcOptions);
          console.log("[addConnection] windowId: " + windowId);
          console.log("[addConnection] options: " + webRtcOptions);

          // Highlight the navigation
          var navElt = document.getElementById("nav_" + videoId);
          navElt.className = "active";

          // Register WebRTC streamer connection
          webRtcServerList[videoId] = webRtcClient;
        }
      }

      /**
       * Load/unload callbacks
       */
      window.onload = function () {
        WebRtcStreamer.getMediaList()
          .then((response) => response.json())
          .then((response) => updateMediaList(response));
      };
      window.onbeforeunload = function () {
        for (var url in webRtcServerList) {
          webRtcServerList[url].disconnect();
        }
      };
    </script>
  </head>

  <body>
    <nav id="menu"></nav>
    <div id="content"></div>
    <footer id="footer"></footer>
  </body>
</html>
